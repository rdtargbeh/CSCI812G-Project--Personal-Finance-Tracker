package csci812_project.backend.entity;

import csci812_project.backend.enums.SubscriptionStatus;
import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "subscriptions")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Subscription {

    /**
     * Unique subscription ID (Primary Key).
     * Auto-generated by the database.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "subscription_id")
    private Long id;

    /**
     * Foreign Key linking the subscription to a user.
     * Ensures that each subscription is assigned to a specific user.
     */
    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false, foreignKey = @ForeignKey(name = "fk_subscription_user"))
    private User user;

    /**
     * Subscription name (e.g., "Netflix", "Gym Membership").
     * Required field.
     */
    @Column(name = "name", nullable = false, length = 100)
    @NotBlank(message = "Subscription name is required")
    private String name;

    /**
     * Monthly charge amount for the subscription.
     * Cannot be negative.
     */
    @Column(name = "amount", nullable = false, precision = 15, scale = 2)
    @DecimalMin(value = "0.00", message = "Amount cannot be negative")
    private BigDecimal amount;

    /**
     * Date of the next billing cycle.
     * Must be in the present or future.
     */
    @Column(name = "next_billing_date", nullable = false)
    @FutureOrPresent(message = "Next billing date must be today or in the future")
    private LocalDateTime nextBillingDate;

    /**
     * Foreign Key linking to the payment method (Account).
     */
    @ManyToOne
    @JoinColumn(name = "payment_method_id", nullable = false, foreignKey = @ForeignKey(name = "fk_subscription_payment"))
    private Account paymentMethod;

    /**
     * Indicates whether the subscription auto-renews.
     */
    @Column(name = "auto_renew", nullable = false)
    private boolean autoRenew = true;

    /**
     * Status of the subscription (ACTIVE, CANCELLED, PAUSED).
     * Defaults to ACTIVE.
     */
    @Column(name = "status", nullable = false)
    @Enumerated(EnumType.STRING)
    private SubscriptionStatus status = SubscriptionStatus.ACTIVE;

    /**
     * Timestamp for when the subscription was created.
     * Automatically set when a new record is inserted.
     */
    @Column(name = "date_created", updatable = false)
    private LocalDateTime dateCreated = LocalDateTime.now();

    /**
     * Timestamp for when the subscription was last updated.
     * Automatically updates on modification.
     */
    @Column(name = "date_updated")
    private LocalDateTime dateUpdated = LocalDateTime.now();

    /**
     * Lifecycle hook to update the timestamp before updating.
     */
    @PreUpdate
    protected void onUpdate() {
        this.dateUpdated = LocalDateTime.now();
    }
}


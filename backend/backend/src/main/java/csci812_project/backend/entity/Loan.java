package csci812_project.backend.entity;

import csci812_project.backend.enums.LoanStatus;
import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "loans")
@Builder
public class Loan {

    /**
     * Unique loan ID (Primary Key).
     * Auto-generated by the database.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "loan_id")
    private Long id;

    /**
     * Foreign Key linking the loan to a user.
     * Ensures that each loan is assigned to a specific user.
     */
    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false, foreignKey = @ForeignKey(name = "fk_loan_user"))
    private User user;

    /**
     * Name of the lender (Bank, Credit Card Company, etc.).
     * Required field.
     */
    @Column(name = "lender_name", nullable = false, length = 100)
    @NotBlank(message = "Lender name is required")
    private String lenderName;

    /**
     * Total amount borrowed (principal loan amount).
     * Cannot be negative.
     */
    @Column(name = "amount_borrowed", nullable = false, precision = 15, scale = 2)
    @DecimalMin(value = "0.00", message = "Amount borrowed cannot be negative")
    private BigDecimal amountBorrowed;

    /**
     * Outstanding balance on the loan.
     * Cannot be negative.
     */
    @Column(name = "outstanding_balance", nullable = false, precision = 15, scale = 2)
    @DecimalMin(value = "0.00", message = "Outstanding balance cannot be negative")
    private BigDecimal outstandingBalance;

    /**
     * Annual interest rate (%).
     * Cannot be negative.
     */
    @Column(name = "interest_rate", precision = 5, scale = 2)
    @DecimalMin(value = "0.00", message = "Interest rate cannot be negative")
    private BigDecimal interestRate = BigDecimal.ZERO;

    /**
     * Total interest paid over the loan lifetime.
     * Cannot be negative.
     */
    @Column(name = "interest_paid", precision = 15, scale = 2)
    @DecimalMin(value = "0.00", message = "Interest paid cannot be negative")
    private BigDecimal interestPaid = BigDecimal.ZERO;

    /**
     * Fixed monthly installment payment amount.
     * Cannot be negative.
     */
    @Column(name = "monthly_payment", nullable = false, precision = 15, scale = 2)
    @DecimalMin(value = "0.00", message = "Monthly payment cannot be negative")
    private BigDecimal monthlyPayment;

    /**
     * Total amount repaid (principal + interest).
     * Cannot be negative.
     */
    @Column(name = "total_amount_paid", precision = 15, scale = 2)
    @DecimalMin(value = "0.00", message = "Total amount paid cannot be negative")
    private BigDecimal totalAmountPaid = BigDecimal.ZERO;

    /**
     * Loan term in years.
     * Must be greater than 0.
     */
    @Column(name = "number_years", nullable = false)
    @Min(value = 1, message = "Loan term must be at least 1 year")
    private int numberYears;

    /**
     * Next due date for loan repayment.
     */
    @Column(name = "due_date", nullable = false)
    @NotNull(message = "Due date is required")
    private LocalDate dueDate;

    /**
     * Status of the loan (ACTIVE, PAID_OFF, DEFAULTED).
     * Defaults to ACTIVE.
     */
    @Column(name = "status", nullable = false)
    @Enumerated(EnumType.STRING)
    private LoanStatus status = LoanStatus.ACTIVE;

    /**
     * Timestamp for when the loan record was created.
     * Automatically set when a new record is inserted.
     */
    @Column(name = "date_created", updatable = false)
    private LocalDateTime dateCreated = LocalDateTime.now();

    /**
     * Timestamp for when the loan record was last updated.
     * Automatically updates on modification.
     */
    @Column(name = "date_updated")
    private LocalDateTime dateUpdated = LocalDateTime.now();

    /**
     * Lifecycle hook to update the timestamp before updating.
     */
    @PreUpdate
    protected void onUpdate() {
        this.dateUpdated = LocalDateTime.now();
    }
}

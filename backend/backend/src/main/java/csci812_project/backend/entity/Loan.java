package csci812_project.backend.entity;

import csci812_project.backend.enums.LoanStatus;
import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "loans")
public class Loan {

    /**
     * Unique loan ID (Primary Key).
     * Auto-generated by the database.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "loan_id")
    private Long loanId;

    /**
     * Foreign Key linking the loan to a user.
     * Ensures that each loan is assigned to a specific user.
     */
    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false, foreignKey = @ForeignKey(name = "fk_loan_user"))
    private User user;

    /**
     * Name of the lender (Bank, Credit Card Company, etc.).
     * Required field.
     */
    @Column(name = "lender_name", nullable = false, length = 100)
    @NotBlank(message = "Lender name is required")
    private String lenderName;

    /**
     * Total amount borrowed (principal loan amount).
     * Cannot be negative.
     */
    @Column(name = "amount_borrowed", nullable = false, precision = 15, scale = 2)
    @DecimalMin(value = "0.00", message = "Amount borrowed cannot be negative")
    private BigDecimal amountBorrowed;

    /**
     * Loan term in years.
     * Must be greater than 0.
     */
    @Column(name = "number_of_years", nullable = false)
    @Min(value = 1, message = "Loan term must be at least 1 year")
    private int numberOfYears;

    /**
     * Annual interest rate (%).
     * Cannot be negative.
     */
    @Column(name = "interest_rate", precision = 5, scale = 2)
    @DecimalMin(value = "0.00", message = "Interest rate cannot be negative")
    private BigDecimal interestRate = BigDecimal.ZERO;

    /**
     * Fixed monthly installment payment amount.
     * Cannot be negative.
     */
    @Column(name = "monthly_payment", precision = 15, scale = 2)
    @DecimalMin(value = "0.00", message = "Monthly payment cannot be negative")
    private BigDecimal monthlyPayment;

    /**
     * Outstanding balance on the loan.
     * Cannot be negative.
     */
    @Column(name = "outstanding_balance", precision = 15, scale = 2)
    private BigDecimal outstandingBalance = BigDecimal.ZERO;

    @Column(name = "number_of_loans", nullable = false)
    private Integer  numberOfLoans = 0; // Total number of active loans

    @Column(name = "total_loan_borrowed", precision = 15, scale = 2)
    private BigDecimal totalLoanBorrowed = BigDecimal.ZERO; // Sum of all loans

    @Column(name = "total_outstanding_balance", precision = 15, scale = 2)
    private BigDecimal totalOutstandingBalance = BigDecimal.ZERO; // Remaining debt

    /**
     * Next due date for loan repayment.
     */
    @Column(name = "due_date", nullable = false)
    @NotNull(message = "Due date is required")
    private LocalDate dueDate;

    /**
     * Status of the loan (ACTIVE, PAID_OFF, DEFAULTED).
     * Defaults to ACTIVE.
     */
    @Column(name = "status", nullable = false)
    @Enumerated(EnumType.STRING)
    private LoanStatus status = LoanStatus.ACTIVE;

    @OneToMany(mappedBy = "loan", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<LoanPayment> payments = new ArrayList<>();

    /**
     * Timestamp for when the loan record was created.
     * Automatically set when a new record is inserted.
     */
    @Column(name = "date_created", updatable = false)
    private LocalDateTime dateCreated = LocalDateTime.now();

    /**
     * Timestamp for when the loan record was last updated.
     * Automatically updates on modification.
     */
    @Column(name = "date_updated")
    private LocalDateTime dateUpdated = LocalDateTime.now();

    /**
     * Lifecycle hook to update the timestamp before updating.
     */
    @PreUpdate
    protected void onUpdate() {
        this.dateUpdated = LocalDateTime.now();
    }

    /**
     * ✅ Calculates the fixed monthly payment based on loan terms.
     */
    public void calculateMonthlyPayment() {
        if (numberOfYears <= 0) {
            throw new RuntimeException("Loan term must be at least 1 year!");
        }

        if (interestRate.compareTo(BigDecimal.ZERO) == 0) {
            // ✅ Handle 0% interest case separately
            this.monthlyPayment = amountBorrowed
                    .divide(BigDecimal.valueOf(numberOfYears * 12), 2, RoundingMode.HALF_UP);
            return;
        }

        BigDecimal monthlyInterestRate = interestRate.divide(BigDecimal.valueOf(100 * 12), 10, RoundingMode.HALF_UP);
        int totalPayments = numberOfYears * 12;

        BigDecimal numerator = amountBorrowed.multiply(monthlyInterestRate)
                .multiply((BigDecimal.ONE.add(monthlyInterestRate)).pow(totalPayments));

        BigDecimal denominator = (BigDecimal.ONE.add(monthlyInterestRate)).pow(totalPayments).subtract(BigDecimal.ONE);

        if (denominator.compareTo(BigDecimal.ZERO) == 0) {
            throw new RuntimeException("Invalid loan parameters: Division by zero in monthly payment calculation.");
        }

        this.monthlyPayment = numerator.divide(denominator, 2, RoundingMode.HALF_UP);
    }


    /**
     * ✅ Updates the loan status based on repayment progress.
     */
    public void updateLoanStatus() {
        if (outstandingBalance.compareTo(BigDecimal.ZERO) == 0) {
            this.status = LoanStatus.PAID_OFF;
        } else if (dueDate.isBefore(LocalDate.now().minusDays(60))) {
            this.status = LoanStatus.DEFAULTED;
        } else {
            this.status = LoanStatus.ACTIVE;
        }
    }

    /**
     * ✅ Updates the next due date after a payment.
     */
    public void updateNextDueDate() {
        if (this.dueDate == null) {
            this.dueDate = LocalDate.now().plusMonths(1); // ✅ Set first due date if missing
        } else {
            this.dueDate = this.dueDate.plusMonths(1); // ✅ Move due date forward by 1 month
        }
    }


    // Constructor
    public Loan(){}

    public Loan(Long loanId, User user, String lenderName, BigDecimal amountBorrowed, int numberOfYears, BigDecimal interestRate,
                BigDecimal monthlyPayment, BigDecimal outstandingBalance, Integer  numberOfLoans, BigDecimal totalLoanBorrowed,
                BigDecimal totalOutstandingBalance, LocalDate dueDate, LoanStatus status, List<LoanPayment> payments,
                LocalDateTime dateCreated, LocalDateTime dateUpdated) {
        this.loanId = loanId;
        this.user = user;
        this.lenderName = lenderName;
        this.amountBorrowed = amountBorrowed;
        this.numberOfYears = numberOfYears;
        this.interestRate = interestRate;
        this.monthlyPayment = monthlyPayment;
        this.outstandingBalance = outstandingBalance;
        this.numberOfLoans = numberOfLoans;
        this.totalLoanBorrowed = totalLoanBorrowed;
        this.totalOutstandingBalance = totalOutstandingBalance;
        this.dueDate = dueDate;
        this.status = status;
        this.payments = payments;
        this.dateCreated = dateCreated;
        this.dateUpdated = dateUpdated;
    }

    // Getter and Setter
    public Long getLoanId() {
        return loanId;
    }

    public void setLoanId(Long loanId) {
        this.loanId = loanId;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public @NotBlank(message = "Lender name is required") String getLenderName() {
        return lenderName;
    }

    public void setLenderName(@NotBlank(message = "Lender name is required") String lenderName) {
        this.lenderName = lenderName;
    }

    public @DecimalMin(value = "0.00", message = "Amount borrowed cannot be negative") BigDecimal getAmountBorrowed() {
        return amountBorrowed;
    }

    public void setAmountBorrowed(@DecimalMin(value = "0.00", message = "Amount borrowed cannot be negative") BigDecimal amountBorrowed) {
        this.amountBorrowed = amountBorrowed;
    }

    public @DecimalMin(value = "0.00", message = "Interest rate cannot be negative") BigDecimal getInterestRate() {
        return interestRate;
    }

    public void setInterestRate(@DecimalMin(value = "0.00", message = "Interest rate cannot be negative") BigDecimal interestRate) {
        this.interestRate = interestRate;
    }

    public @DecimalMin(value = "0.00", message = "Monthly payment cannot be negative") BigDecimal getMonthlyPayment() {
        return monthlyPayment;
    }

    public void setMonthlyPayment(@DecimalMin(value = "0.00", message = "Monthly payment cannot be negative") BigDecimal monthlyPayment) {
        this.monthlyPayment = monthlyPayment;
    }

    @Min(value = 1, message = "Loan term must be at least 1 year")
    public int getNumberOfYears() {
        return numberOfYears;
    }

    public void setNumberOfYears(@Min(value = 1, message = "Loan term must be at least 1 year") int numberOfYears) {
        this.numberOfYears = numberOfYears;
    }

    public @NotNull(message = "Due date is required") LocalDate getDueDate() {
        return dueDate;
    }

    public void setDueDate(@NotNull(message = "Due date is required") LocalDate dueDate) {
        this.dueDate = dueDate;
    }

    public LoanStatus getStatus() {
        return status;
    }

    public void setStatus(LoanStatus status) {
        this.status = status;
    }

    public LocalDateTime getDateCreated() {
        return dateCreated;
    }

    public void setDateCreated(LocalDateTime dateCreated) {
        this.dateCreated = dateCreated;
    }

    public LocalDateTime getDateUpdated() {
        return dateUpdated;
    }

    public void setDateUpdated(LocalDateTime dateUpdated) {
        this.dateUpdated = dateUpdated;
    }

    public List<LoanPayment> getPayments() {
        return payments;
    }

    public void setPayments(List<LoanPayment> payments) {
        this.payments = payments;
    }

    public BigDecimal getOutstandingBalance() {
        return outstandingBalance;
    }

    public void setOutstandingBalance(BigDecimal outstandingBalance) {
        this.outstandingBalance = outstandingBalance;
    }

    public Integer  getNumberOfLoans() {
        return numberOfLoans;
    }

    public void setNumberOfLoans(Integer  numberOfLoans) {
        this.numberOfLoans = numberOfLoans;
    }

    public BigDecimal getTotalLoanBorrowed() {
        return totalLoanBorrowed;
    }

    public void setTotalLoanBorrowed(BigDecimal totalLoanBorrowed) {
        this.totalLoanBorrowed = totalLoanBorrowed;
    }

    public BigDecimal getTotalOutstandingBalance() {
        return totalOutstandingBalance;
    }

    public void setTotalOutstandingBalance(BigDecimal totalOutstandingBalance) {
        this.totalOutstandingBalance = totalOutstandingBalance;
    }
}

package csci812_project.backend.entity;

import csci812_project.backend.enums.LoanStatus;
import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "loans")
public class Loan {

    /**
     * Unique loan ID (Primary Key).
     * Auto-generated by the database.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "loan_id")
    private Long loanId;

    /**
     * Foreign Key linking the loan to a user.
     * Ensures that each loan is assigned to a specific user.
     */
    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false, foreignKey = @ForeignKey(name = "fk_loan_user"))
    private User user;

    /**
     * Name of the lender (Bank, Credit Card Company, etc.).
     * Required field.
     */
    @Column(name = "lender_name", nullable = false, length = 100)
    @NotBlank(message = "Lender name is required")
    private String lenderName;

    /**
     * Total amount borrowed (principal loan amount).
     * Cannot be negative.
     */
    @Column(name = "amount_borrowed", nullable = false, precision = 15, scale = 2)
    @DecimalMin(value = "0.00", message = "Amount borrowed cannot be negative")
    private BigDecimal amountBorrowed;

    /**
     * Outstanding balance on the loan.
     * Cannot be negative.
     */
    @Column(name = "outstanding_balance", nullable = false, precision = 15, scale = 2)
    @DecimalMin(value = "0.00", message = "Outstanding balance cannot be negative")
    private BigDecimal outstandingBalance;

    /**
     * Annual interest rate (%).
     * Cannot be negative.
     */
    @Column(name = "interest_rate", precision = 5, scale = 2)
    @DecimalMin(value = "0.00", message = "Interest rate cannot be negative")
    private BigDecimal interestRate = BigDecimal.ZERO;

    /**
     * Total interest paid over the loan lifetime.
     * Cannot be negative.
     */
    @Column(name = "interest_paid", precision = 15, scale = 2)
    @DecimalMin(value = "0.00", message = "Interest paid cannot be negative")
    private BigDecimal interestPaid = BigDecimal.ZERO;

    /**
     * Fixed monthly installment payment amount.
     * Cannot be negative.
     */
    @Column(name = "monthly_payment", nullable = false, precision = 15, scale = 2)
    @DecimalMin(value = "0.00", message = "Monthly payment cannot be negative")
    private BigDecimal monthlyPayment;

    /**
     * Total amount repaid (principal + interest).
     * Cannot be negative.
     */
    @Column(name = "total_amount_paid", precision = 15, scale = 2)
    @DecimalMin(value = "0.00", message = "Total amount paid cannot be negative")
    private BigDecimal totalAmountPaid = BigDecimal.ZERO;

    /**
     * Loan term in years.
     * Must be greater than 0.
     */
    @Column(name = "number_years", nullable = false)
    @Min(value = 1, message = "Loan term must be at least 1 year")
    private int numberYears;

    /**
     * Next due date for loan repayment.
     */
    @Column(name = "due_date", nullable = false)
    @NotNull(message = "Due date is required")
    private LocalDate dueDate;

    /**
     * Status of the loan (ACTIVE, PAID_OFF, DEFAULTED).
     * Defaults to ACTIVE.
     */
    @Column(name = "status", nullable = false)
    @Enumerated(EnumType.STRING)
    private LoanStatus status = LoanStatus.ACTIVE;

    /**
     * Timestamp for when the loan record was created.
     * Automatically set when a new record is inserted.
     */
    @Column(name = "date_created", updatable = false)
    private LocalDateTime dateCreated = LocalDateTime.now();

    /**
     * Timestamp for when the loan record was last updated.
     * Automatically updates on modification.
     */
    @Column(name = "date_updated")
    private LocalDateTime dateUpdated = LocalDateTime.now();


    /**
     * Lifecycle hook to update the timestamp before updating.
     */
    @PreUpdate
    protected void onUpdate() {
        this.dateUpdated = LocalDateTime.now();
    }

    /**
     * ✅ Calculates the fixed monthly payment based on loan terms.
     */
    public void calculateMonthlyPayment() {
        if (interestRate.compareTo(BigDecimal.ZERO) == 0) {
            // If 0% interest, simple division
            this.monthlyPayment = amountBorrowed
                    .divide(BigDecimal.valueOf(numberYears * 12), 2, RoundingMode.HALF_UP);
        } else {
            BigDecimal monthlyInterestRate = interestRate.divide(BigDecimal.valueOf(12 * 100), 10, RoundingMode.HALF_UP);
            int totalPayments = numberYears * 12;

            BigDecimal numerator = amountBorrowed.multiply(monthlyInterestRate)
                    .multiply((BigDecimal.ONE.add(monthlyInterestRate)).pow(totalPayments));

            BigDecimal denominator = (BigDecimal.ONE.add(monthlyInterestRate)).pow(totalPayments).subtract(BigDecimal.ONE);

            this.monthlyPayment = numerator.divide(denominator, 2, RoundingMode.HALF_UP);
        }
    }


    /**
     * ✅ Calculates the total amount paid over the loan period.
     */
    public void calculateTotalAmountPaid() {
        int totalMonths = numberYears * 12;
        this.totalAmountPaid = this.monthlyPayment.multiply(BigDecimal.valueOf(totalMonths));
    }

    /**
     * ✅ Calculates the total interest paid over the loan period.
     */
    public void calculateTotalInterestPaid() {
        this.interestPaid = this.totalAmountPaid.subtract(this.amountBorrowed);
    }

    /**
     * ✅ Updates the due date for the next monthly payment.
     */
    public void updateNextDueDate() {
        this.dueDate = (this.dueDate == null) ? LocalDate.now().plusMonths(1) : this.dueDate.plusMonths(1);
    }


    /**
     * ✅ Updates the loan status based on repayment progress.
     */
    public void updateLoanStatus() {
        if (outstandingBalance.compareTo(BigDecimal.ZERO) == 0) {
            this.status = LoanStatus.PAID_OFF;
        } else if (dueDate.isBefore(LocalDate.now().minusDays(60))) {
            this.status = LoanStatus.DEFAULTED;
        } else {
            this.status = LoanStatus.ACTIVE;
        }
    }

    // Constructor
    public Loan(){}
    public Loan(Long loanId, User user, String lenderName, BigDecimal amountBorrowed, BigDecimal outstandingBalance, BigDecimal interestRate,
                BigDecimal interestPaid, BigDecimal monthlyPayment, BigDecimal totalAmountPaid, int numberYears, LocalDate dueDate,
                LoanStatus status, LocalDateTime dateCreated, LocalDateTime dateUpdated) {
        this.loanId = loanId;
        this.user = user;
        this.lenderName = lenderName;
        this.amountBorrowed = amountBorrowed;
        this.outstandingBalance = outstandingBalance;
        this.interestRate = interestRate;
        this.interestPaid = interestPaid;
        this.monthlyPayment = monthlyPayment;
        this.totalAmountPaid = totalAmountPaid;
        this.numberYears = numberYears;
        this.dueDate = dueDate;
        this.status = status;
        this.dateCreated = dateCreated;
        this.dateUpdated = dateUpdated;

    }

    // Getter and Setter
    public Long getLoanId() {
        return loanId;
    }

    public void setLoanId(Long loanId) {
        this.loanId = loanId;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public @NotBlank(message = "Lender name is required") String getLenderName() {
        return lenderName;
    }

    public void setLenderName(@NotBlank(message = "Lender name is required") String lenderName) {
        this.lenderName = lenderName;
    }

    public @DecimalMin(value = "0.00", message = "Amount borrowed cannot be negative") BigDecimal getAmountBorrowed() {
        return amountBorrowed;
    }

    public void setAmountBorrowed(@DecimalMin(value = "0.00", message = "Amount borrowed cannot be negative") BigDecimal amountBorrowed) {
        this.amountBorrowed = amountBorrowed;
    }

    public @DecimalMin(value = "0.00", message = "Outstanding balance cannot be negative") BigDecimal getOutstandingBalance() {
        return outstandingBalance;
    }

    public void setOutstandingBalance(@DecimalMin(value = "0.00", message = "Outstanding balance cannot be negative") BigDecimal outstandingBalance) {
        this.outstandingBalance = outstandingBalance;
    }

    public @DecimalMin(value = "0.00", message = "Interest rate cannot be negative") BigDecimal getInterestRate() {
        return interestRate;
    }

    public void setInterestRate(@DecimalMin(value = "0.00", message = "Interest rate cannot be negative") BigDecimal interestRate) {
        this.interestRate = interestRate;
    }

    public @DecimalMin(value = "0.00", message = "Interest paid cannot be negative") BigDecimal getInterestPaid() {
        return interestPaid;
    }

    public void setInterestPaid(@DecimalMin(value = "0.00", message = "Interest paid cannot be negative") BigDecimal interestPaid) {
        this.interestPaid = interestPaid;
    }

    public @DecimalMin(value = "0.00", message = "Monthly payment cannot be negative") BigDecimal getMonthlyPayment() {
        return monthlyPayment;
    }

    public void setMonthlyPayment(@DecimalMin(value = "0.00", message = "Monthly payment cannot be negative") BigDecimal monthlyPayment) {
        this.monthlyPayment = monthlyPayment;
    }

    public @DecimalMin(value = "0.00", message = "Total amount paid cannot be negative") BigDecimal getTotalAmountPaid() {
        return totalAmountPaid;
    }

    public void setTotalAmountPaid(@DecimalMin(value = "0.00", message = "Total amount paid cannot be negative") BigDecimal totalAmountPaid) {
        this.totalAmountPaid = totalAmountPaid;
    }

    @Min(value = 1, message = "Loan term must be at least 1 year")
    public int getNumberYears() {
        return numberYears;
    }

    public void setNumberYears(@Min(value = 1, message = "Loan term must be at least 1 year") int numberYears) {
        this.numberYears = numberYears;
    }

    public @NotNull(message = "Due date is required") LocalDate getDueDate() {
        return dueDate;
    }

    public void setDueDate(@NotNull(message = "Due date is required") LocalDate dueDate) {
        this.dueDate = dueDate;
    }

    public LoanStatus getStatus() {
        return status;
    }

    public void setStatus(LoanStatus status) {
        this.status = status;
    }

    public LocalDateTime getDateCreated() {
        return dateCreated;
    }

    public void setDateCreated(LocalDateTime dateCreated) {
        this.dateCreated = dateCreated;
    }

    public LocalDateTime getDateUpdated() {
        return dateUpdated;
    }

    public void setDateUpdated(LocalDateTime dateUpdated) {
        this.dateUpdated = dateUpdated;
    }


}
